from ..core.predictor import predictor
from ..adapters.llm import LLM
from typing import Annotated

@predictor(LLM())
def code_generate(
    declarations: Annotated[str, "function definition"]
) -> Annotated[str, "python code that answers the question"]:
    """In the `input`, the function definition is provided. Complete the function code."""
    return ...

@predictor(LLM())
def code_regenerate(
    code: Annotated[str, "Previously generated python code that encountered syntax error."],
    error: Annotated[dict, "Error message generated by previously compile python code."]
) -> Annotated[str, "python code that answers the question"]:
    """Corrected python code syntax errors"""
    return ...

def code_compile(code: str):
    try:
        code_exec = compile(code, '<string>', 'exec')
        error = None
    except SyntaxError as e:
        code_exec = None
        error = {
            'lineno': e.lineno,
            'text': e.text,
            'offset': e.offset,
            'msg': e.msg
        }
    return code_exec, error

def pot(declarations: str, max_iters: int = 2):
    code = code_generate(declarations)
    hop = 0
    while True:
        code_exec, error = code_compile(code)
        if not error:
            return code
        hop += 1
        if hop >= max_iters:
            raise RuntimeError("Max hops reached. Error persists.")
        code = code_regenerate(code, error)
